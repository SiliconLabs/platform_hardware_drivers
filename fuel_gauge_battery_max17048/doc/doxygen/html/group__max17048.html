<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: - Fuel Gauge Sensor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">- Fuel Gauge Sensor</div></div>
</div><!--header-->
<div class="contents">

<p>Driver for the max17048/max17049 Fuel Gauge.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga680a8aa2a20465cfbcb7fdf9208c5e77"><td class="memItemLeft" align="right" valign="top">typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga680a8aa2a20465cfbcb7fdf9208c5e77">max17048_temp_callback_t</a>) (void)</td></tr>
<tr class="memdesc:ga680a8aa2a20465cfbcb7fdf9208c5e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">MAX17048 temperature external temperature measurement callback function.  <a href="group__max17048.html#ga680a8aa2a20465cfbcb7fdf9208c5e77">More...</a><br /></td></tr>
<tr class="separator:ga680a8aa2a20465cfbcb7fdf9208c5e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5328c547b89d1e336b44390abc4965d0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a>) (sl_max17048_irq_source_t irq, void *data)</td></tr>
<tr class="memdesc:ga5328c547b89d1e336b44390abc4965d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">MAX17048 interrupt callback function.  <a href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">More...</a><br /></td></tr>
<tr class="separator:ga5328c547b89d1e336b44390abc4965d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3f9e19d54b68f884baa1de9580909b33"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga3f9e19d54b68f884baa1de9580909b33">max17048_hibstate_t</a> { <a class="el" href="group__max17048.html#gga3f9e19d54b68f884baa1de9580909b33aa9827654cde2568f4f082c27746fa59f">activeMode</a> = 0
, <a class="el" href="group__max17048.html#gga3f9e19d54b68f884baa1de9580909b33a59f864cf7b64c780506d1d358f9613f1">hibernateMode</a> = 1
 }</td></tr>
<tr class="memdesc:ga3f9e19d54b68f884baa1de9580909b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">MAX17048 hibernate state.  <a href="group__max17048.html#ga3f9e19d54b68f884baa1de9580909b33">More...</a><br /></td></tr>
<tr class="separator:ga3f9e19d54b68f884baa1de9580909b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacf8057a06dab423031f8e07cf7e80027"><td class="memItemLeft" align="right" valign="top"><a id="gacf8057a06dab423031f8e07cf7e80027" name="gacf8057a06dab423031f8e07cf7e80027"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAX17048_ENUM</b> (sl_max17048_irq_source_t)</td></tr>
<tr class="memdesc:gacf8057a06dab423031f8e07cf7e80027"><td class="mdescLeft">&#160;</td><td class="mdescRight">MAX17048 interrupt source enum. <br /></td></tr>
<tr class="separator:gacf8057a06dab423031f8e07cf7e80027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a4ac6a6d0d0f98d0cf6388a21d8214"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga46a4ac6a6d0d0f98d0cf6388a21d8214">max17048_init</a> (sl_i2cspm_t *i2cspm)</td></tr>
<tr class="memdesc:ga46a4ac6a6d0d0f98d0cf6388a21d8214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the MAX17048 driver with the values provided in the <a class="el" href="max17048__config_8h.html" title="MAX17048 Driver Configuration.">max17048_config.h</a> file.  <a href="group__max17048.html#ga46a4ac6a6d0d0f98d0cf6388a21d8214">More...</a><br /></td></tr>
<tr class="separator:ga46a4ac6a6d0d0f98d0cf6388a21d8214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3da20249b4ef2fbd8dbab8fe45971c18"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga3da20249b4ef2fbd8dbab8fe45971c18">max17048_deinit</a> (void)</td></tr>
<tr class="memdesc:ga3da20249b4ef2fbd8dbab8fe45971c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize the MAX17048 driver.  <a href="group__max17048.html#ga3da20249b4ef2fbd8dbab8fe45971c18">More...</a><br /></td></tr>
<tr class="separator:ga3da20249b4ef2fbd8dbab8fe45971c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66c5ab7163803d9d4f9b5c6beeb48c7"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gaf66c5ab7163803d9d4f9b5c6beeb48c7">max17048_get_vcell</a> (uint32_t *vcell)</td></tr>
<tr class="memdesc:gaf66c5ab7163803d9d4f9b5c6beeb48c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the cell voltage in millivolts.  <a href="group__max17048.html#gaf66c5ab7163803d9d4f9b5c6beeb48c7">More...</a><br /></td></tr>
<tr class="separator:gaf66c5ab7163803d9d4f9b5c6beeb48c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac6d8d7bb558efbae9bb013b97bff22"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga6ac6d8d7bb558efbae9bb013b97bff22">max17048_get_soc</a> (uint32_t *soc)</td></tr>
<tr class="memdesc:ga6ac6d8d7bb558efbae9bb013b97bff22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns SOC as an integer %.  <a href="group__max17048.html#ga6ac6d8d7bb558efbae9bb013b97bff22">More...</a><br /></td></tr>
<tr class="separator:ga6ac6d8d7bb558efbae9bb013b97bff22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3ff8a523f2a234df0e47965554160f"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga1f3ff8a523f2a234df0e47965554160f">max17048_get_crate</a> (float *crate)</td></tr>
<tr class="memdesc:ga1f3ff8a523f2a234df0e47965554160f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets an approximate value for the average SOC rate of change.  <a href="group__max17048.html#ga1f3ff8a523f2a234df0e47965554160f">More...</a><br /></td></tr>
<tr class="separator:ga1f3ff8a523f2a234df0e47965554160f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d1f3ab66a445b1289f38f1483b6425"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gaa1d1f3ab66a445b1289f38f1483b6425">max17048_register_temperature_callback</a> (<a class="el" href="group__max17048.html#ga680a8aa2a20465cfbcb7fdf9208c5e77">max17048_temp_callback_t</a> temp_cb)</td></tr>
<tr class="memdesc:gaa1d1f3ab66a445b1289f38f1483b6425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the temperature update callback for the MAX17048 driver.  <a href="group__max17048.html#gaa1d1f3ab66a445b1289f38f1483b6425">More...</a><br /></td></tr>
<tr class="separator:gaa1d1f3ab66a445b1289f38f1483b6425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e42578f78e2d4d25ef8c875dc6f96e"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga42e42578f78e2d4d25ef8c875dc6f96e">max17048_unregister_temperature_callback</a> (void)</td></tr>
<tr class="memdesc:ga42e42578f78e2d4d25ef8c875dc6f96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the temperature update callback for the MAX17048 driver.  <a href="group__max17048.html#ga42e42578f78e2d4d25ef8c875dc6f96e">More...</a><br /></td></tr>
<tr class="separator:ga42e42578f78e2d4d25ef8c875dc6f96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474f195b19fba6d349818c42f0853ced"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga474f195b19fba6d349818c42f0853ced">max17048_set_update_interval</a> (uint32_t interval)</td></tr>
<tr class="memdesc:ga474f195b19fba6d349818c42f0853ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RCOMP update interval.  <a href="group__max17048.html#ga474f195b19fba6d349818c42f0853ced">More...</a><br /></td></tr>
<tr class="separator:ga474f195b19fba6d349818c42f0853ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e14c854a21af022ebd49b78b520e8d1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga2e14c854a21af022ebd49b78b520e8d1">max17048_get_update_interval</a> (void)</td></tr>
<tr class="memdesc:ga2e14c854a21af022ebd49b78b520e8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RCOMP update interval.  <a href="group__max17048.html#ga2e14c854a21af022ebd49b78b520e8d1">More...</a><br /></td></tr>
<tr class="separator:ga2e14c854a21af022ebd49b78b520e8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4dd46a920d4d1e44bb868038c692fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga6c4dd46a920d4d1e44bb868038c692fc">max17048_mask_interrupts</a> (void)</td></tr>
<tr class="memdesc:ga6c4dd46a920d4d1e44bb868038c692fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask MAX17048 interrupts.  <a href="group__max17048.html#ga6c4dd46a920d4d1e44bb868038c692fc">More...</a><br /></td></tr>
<tr class="separator:ga6c4dd46a920d4d1e44bb868038c692fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga048dfd6319ccc78e656d5f2819357c7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga048dfd6319ccc78e656d5f2819357c7d">max17048_unmask_interrupts</a> (void)</td></tr>
<tr class="memdesc:ga048dfd6319ccc78e656d5f2819357c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmask MAX17048 interrupts.  <a href="group__max17048.html#ga048dfd6319ccc78e656d5f2819357c7d">More...</a><br /></td></tr>
<tr class="separator:ga048dfd6319ccc78e656d5f2819357c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8c520e91572655c43d29e586bfc2686"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gaa8c520e91572655c43d29e586bfc2686">max17048_enable_soc_interrupt</a> (<a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a> irq_cb, void *cb_data)</td></tr>
<tr class="memdesc:gaa8c520e91572655c43d29e586bfc2686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the MAX17048 state-of-charge (SOC) interrupt and registers a user-provided callback function to respond to it.  <a href="group__max17048.html#gaa8c520e91572655c43d29e586bfc2686">More...</a><br /></td></tr>
<tr class="separator:gaa8c520e91572655c43d29e586bfc2686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a770f000e304210f9816b29f3f1868"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gad7a770f000e304210f9816b29f3f1868">max17048_disable_soc_interrupt</a> (void)</td></tr>
<tr class="memdesc:gad7a770f000e304210f9816b29f3f1868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the MAX17048 state-of-charge (SOC) interrupt and unregisters the user-provided callback function.  <a href="group__max17048.html#gad7a770f000e304210f9816b29f3f1868">More...</a><br /></td></tr>
<tr class="separator:gad7a770f000e304210f9816b29f3f1868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4496efacef0e093d718a236029780ecc"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga4496efacef0e093d718a236029780ecc">max17048_enable_empty_interrupt</a> (uint8_t athd, <a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a> irq_cb, void *cb_data)</td></tr>
<tr class="memdesc:ga4496efacef0e093d718a236029780ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the MAX17048 empty alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it.  <a href="group__max17048.html#ga4496efacef0e093d718a236029780ecc">More...</a><br /></td></tr>
<tr class="separator:ga4496efacef0e093d718a236029780ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b10be8d77646d016c1f42637d8fe551"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga7b10be8d77646d016c1f42637d8fe551">max17048_disable_empty_interrupt</a> (void)</td></tr>
<tr class="memdesc:ga7b10be8d77646d016c1f42637d8fe551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the MAX17048 empty alert interrupt and unregisters the the user-provided callback function.  <a href="group__max17048.html#ga7b10be8d77646d016c1f42637d8fe551">More...</a><br /></td></tr>
<tr class="separator:ga7b10be8d77646d016c1f42637d8fe551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga129619245c3f1ae5b376c537d734a7ef"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga129619245c3f1ae5b376c537d734a7ef">max17048_set_empty_threshold</a> (uint8_t athd)</td></tr>
<tr class="memdesc:ga129619245c3f1ae5b376c537d734a7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the empty threshold.  <a href="group__max17048.html#ga129619245c3f1ae5b376c537d734a7ef">More...</a><br /></td></tr>
<tr class="separator:ga129619245c3f1ae5b376c537d734a7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07d953475034869fee5623b842a5d26"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gaf07d953475034869fee5623b842a5d26">max17048_get_empty_threshold</a> (void)</td></tr>
<tr class="memdesc:gaf07d953475034869fee5623b842a5d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the empty threshold.  <a href="group__max17048.html#gaf07d953475034869fee5623b842a5d26">More...</a><br /></td></tr>
<tr class="separator:gaf07d953475034869fee5623b842a5d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dc052e99940eb937d2648195ba8ec79"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga2dc052e99940eb937d2648195ba8ec79">max17048_enable_vhigh_interrupt</a> (uint32_t valrt_max_mv, <a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a> irq_cb, void *cb_data)</td></tr>
<tr class="memdesc:ga2dc052e99940eb937d2648195ba8ec79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the MAX17048 voltage high alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it.  <a href="group__max17048.html#ga2dc052e99940eb937d2648195ba8ec79">More...</a><br /></td></tr>
<tr class="separator:ga2dc052e99940eb937d2648195ba8ec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ceb5d1e51b85b9812f6e01c90f88324"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga3ceb5d1e51b85b9812f6e01c90f88324">max17048_disable_vhigh_interrupt</a> (void)</td></tr>
<tr class="memdesc:ga3ceb5d1e51b85b9812f6e01c90f88324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the MAX17048 voltage high alert interrupt and unregisters the user-provided callback function.  <a href="group__max17048.html#ga3ceb5d1e51b85b9812f6e01c90f88324">More...</a><br /></td></tr>
<tr class="separator:ga3ceb5d1e51b85b9812f6e01c90f88324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2222b6efb1cd395ebe51e14aa5e22c88"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga2222b6efb1cd395ebe51e14aa5e22c88">max17048_set_vhigh_threshold</a> (uint32_t valrt_max_mv)</td></tr>
<tr class="memdesc:ga2222b6efb1cd395ebe51e14aa5e22c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the voltage high alert interrupt threshold.  <a href="group__max17048.html#ga2222b6efb1cd395ebe51e14aa5e22c88">More...</a><br /></td></tr>
<tr class="separator:ga2222b6efb1cd395ebe51e14aa5e22c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae239698bfaeec936f207d921b65e3caf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gae239698bfaeec936f207d921b65e3caf">max17048_get_vhigh_threshold</a> (void)</td></tr>
<tr class="memdesc:gae239698bfaeec936f207d921b65e3caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the voltage high alert interrupt threshold.  <a href="group__max17048.html#gae239698bfaeec936f207d921b65e3caf">More...</a><br /></td></tr>
<tr class="separator:gae239698bfaeec936f207d921b65e3caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44da5bcac4b8d24431134c43efc661db"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga44da5bcac4b8d24431134c43efc661db">max17048_enable_vlow_interrupt</a> (uint32_t valrt_min_mv, <a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a> irq_cb, void *cb_data)</td></tr>
<tr class="memdesc:ga44da5bcac4b8d24431134c43efc661db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the MAX17048 voltage low alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it.  <a href="group__max17048.html#ga44da5bcac4b8d24431134c43efc661db">More...</a><br /></td></tr>
<tr class="separator:ga44da5bcac4b8d24431134c43efc661db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5383af8dbe8910543f0cbd5cacb0b841"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga5383af8dbe8910543f0cbd5cacb0b841">max17048_disable_vlow_interrupt</a> (void)</td></tr>
<tr class="memdesc:ga5383af8dbe8910543f0cbd5cacb0b841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the MAX17048 voltage low alert interrupt and unregisters the user-provided callback function.  <a href="group__max17048.html#ga5383af8dbe8910543f0cbd5cacb0b841">More...</a><br /></td></tr>
<tr class="separator:ga5383af8dbe8910543f0cbd5cacb0b841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bbe2d0282a213364c9b00cb6476a5f5"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga4bbe2d0282a213364c9b00cb6476a5f5">max17048_set_vlow_threshold</a> (uint32_t valrt_min_mv)</td></tr>
<tr class="memdesc:ga4bbe2d0282a213364c9b00cb6476a5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the voltage low alert interrupt threshold.  <a href="group__max17048.html#ga4bbe2d0282a213364c9b00cb6476a5f5">More...</a><br /></td></tr>
<tr class="separator:ga4bbe2d0282a213364c9b00cb6476a5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80360aaf5c8235fdfc1df138236231cf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga80360aaf5c8235fdfc1df138236231cf">max17048_get_vlow_threshold</a> (void)</td></tr>
<tr class="memdesc:ga80360aaf5c8235fdfc1df138236231cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the voltage low alert interrupt threshold.  <a href="group__max17048.html#ga80360aaf5c8235fdfc1df138236231cf">More...</a><br /></td></tr>
<tr class="separator:ga80360aaf5c8235fdfc1df138236231cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d5f41ce5b13ed29b0cb796ccd2b723"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga77d5f41ce5b13ed29b0cb796ccd2b723">max17048_enable_reset_interrupt</a> (uint32_t vreset_mv, <a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a> irq_cb, void *cb_data)</td></tr>
<tr class="memdesc:ga77d5f41ce5b13ed29b0cb796ccd2b723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the MAX17048 reset alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it.  <a href="group__max17048.html#ga77d5f41ce5b13ed29b0cb796ccd2b723">More...</a><br /></td></tr>
<tr class="separator:ga77d5f41ce5b13ed29b0cb796ccd2b723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284f22aa25c9d4519842e8a2ac57c44f"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga284f22aa25c9d4519842e8a2ac57c44f">max17048_disable_reset_interrupt</a> (void)</td></tr>
<tr class="memdesc:ga284f22aa25c9d4519842e8a2ac57c44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the MAX17048 reset alert interrupt and unregisters the user-provided callback function.  <a href="group__max17048.html#ga284f22aa25c9d4519842e8a2ac57c44f">More...</a><br /></td></tr>
<tr class="separator:ga284f22aa25c9d4519842e8a2ac57c44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b238189efc62b2cbab34f6e75a11ec"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gab3b238189efc62b2cbab34f6e75a11ec">max17048_set_reset_threshold</a> (uint32_t vreset_mv)</td></tr>
<tr class="memdesc:gab3b238189efc62b2cbab34f6e75a11ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reset alert interrupt threshold.  <a href="group__max17048.html#gab3b238189efc62b2cbab34f6e75a11ec">More...</a><br /></td></tr>
<tr class="separator:gab3b238189efc62b2cbab34f6e75a11ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf4aa694f3692200f09d4c1bc4d42d7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gadbf4aa694f3692200f09d4c1bc4d42d7">max17048_get_reset_threshold</a> (void)</td></tr>
<tr class="memdesc:gadbf4aa694f3692200f09d4c1bc4d42d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reset alert interrupt threshold.  <a href="group__max17048.html#gadbf4aa694f3692200f09d4c1bc4d42d7">More...</a><br /></td></tr>
<tr class="separator:gadbf4aa694f3692200f09d4c1bc4d42d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac461439fc7a6add30ddf2bf7d530e3b7"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gac461439fc7a6add30ddf2bf7d530e3b7">max17048_enable_auto_hibernate</a> (float hib_thr, uint32_t act_thr)</td></tr>
<tr class="memdesc:gac461439fc7a6add30ddf2bf7d530e3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables MAX17048 automatic hibernation by setting the activity and CRATE (rate of discharge/charge) thresholds to non-min/max values.  <a href="group__max17048.html#gac461439fc7a6add30ddf2bf7d530e3b7">More...</a><br /></td></tr>
<tr class="separator:gac461439fc7a6add30ddf2bf7d530e3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84261f39f5f2b4f65376469aa5af7534"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga84261f39f5f2b4f65376469aa5af7534">max17048_disable_auto_hibernate</a> (void)</td></tr>
<tr class="memdesc:ga84261f39f5f2b4f65376469aa5af7534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables automatic hibernation by setting the activity and CRATE thresholds to 0x0.  <a href="group__max17048.html#ga84261f39f5f2b4f65376469aa5af7534">More...</a><br /></td></tr>
<tr class="separator:ga84261f39f5f2b4f65376469aa5af7534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0f4e9bbb181649b9655eb5643892710"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gaf0f4e9bbb181649b9655eb5643892710">max17048_set_hibernate_threshold</a> (float hib_thr)</td></tr>
<tr class="memdesc:gaf0f4e9bbb181649b9655eb5643892710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the hibernate threshold level.  <a href="group__max17048.html#gaf0f4e9bbb181649b9655eb5643892710">More...</a><br /></td></tr>
<tr class="separator:gaf0f4e9bbb181649b9655eb5643892710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d5512602578226a49a978c7e652d5ae"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga4d5512602578226a49a978c7e652d5ae">max17048_get_hibernate_threshold</a> (void)</td></tr>
<tr class="memdesc:ga4d5512602578226a49a978c7e652d5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hibernate threshold level.  <a href="group__max17048.html#ga4d5512602578226a49a978c7e652d5ae">More...</a><br /></td></tr>
<tr class="separator:ga4d5512602578226a49a978c7e652d5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93e51267fe944a8e78c730cc78e6f9d4"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga93e51267fe944a8e78c730cc78e6f9d4">max17048_set_activity_threshold</a> (uint32_t act_thr)</td></tr>
<tr class="memdesc:ga93e51267fe944a8e78c730cc78e6f9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the activity threshold level.  <a href="group__max17048.html#ga93e51267fe944a8e78c730cc78e6f9d4">More...</a><br /></td></tr>
<tr class="separator:ga93e51267fe944a8e78c730cc78e6f9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4dc2d4edfa30523a67483e344f5b989"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gab4dc2d4edfa30523a67483e344f5b989">max17048_get_activity_threshold</a> (void)</td></tr>
<tr class="memdesc:gab4dc2d4edfa30523a67483e344f5b989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the activity threshold level.  <a href="group__max17048.html#gab4dc2d4edfa30523a67483e344f5b989">More...</a><br /></td></tr>
<tr class="separator:gab4dc2d4edfa30523a67483e344f5b989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55975d771f83912b68cd55b059a01e38"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga55975d771f83912b68cd55b059a01e38">max17048_enable_reset_comparator</a> (bool enable)</td></tr>
<tr class="memdesc:ga55975d771f83912b68cd55b059a01e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disabling the MAX17048 reset comparator in hibernate mode reduces current consumption by 0.5 uA.  <a href="group__max17048.html#ga55975d771f83912b68cd55b059a01e38">More...</a><br /></td></tr>
<tr class="separator:ga55975d771f83912b68cd55b059a01e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66daaef0642f1f20fb6a7583a31df836"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga66daaef0642f1f20fb6a7583a31df836">max17048_get_hibernate_state</a> (<a class="el" href="group__max17048.html#ga3f9e19d54b68f884baa1de9580909b33">max17048_hibstate_t</a> *hibstat)</td></tr>
<tr class="memdesc:ga66daaef0642f1f20fb6a7583a31df836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the MAX17048 is in hibernate mode.  <a href="group__max17048.html#ga66daaef0642f1f20fb6a7583a31df836">More...</a><br /></td></tr>
<tr class="separator:ga66daaef0642f1f20fb6a7583a31df836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa417efb663c06cd2240cdeb63846a47e"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gaa417efb663c06cd2240cdeb63846a47e">max17048_enter_sleep</a> (void)</td></tr>
<tr class="memdesc:gaa417efb663c06cd2240cdeb63846a47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the MAX17048 into sleep mode.  <a href="group__max17048.html#gaa417efb663c06cd2240cdeb63846a47e">More...</a><br /></td></tr>
<tr class="separator:gaa417efb663c06cd2240cdeb63846a47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6540b9afc85e8af172dd3fc3435bd95f"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga6540b9afc85e8af172dd3fc3435bd95f">max17048_exit_sleep</a> (void)</td></tr>
<tr class="memdesc:ga6540b9afc85e8af172dd3fc3435bd95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the MAX17048 to exit sleep mode.  <a href="group__max17048.html#ga6540b9afc85e8af172dd3fc3435bd95f">More...</a><br /></td></tr>
<tr class="separator:ga6540b9afc85e8af172dd3fc3435bd95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff3d5ffd024c3d275a9258848d8ef52"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga2ff3d5ffd024c3d275a9258848d8ef52">max17048_force_reset</a> (void)</td></tr>
<tr class="memdesc:ga2ff3d5ffd024c3d275a9258848d8ef52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the MAX17048 to initiate a power-on reset (POR).  <a href="group__max17048.html#ga2ff3d5ffd024c3d275a9258848d8ef52">More...</a><br /></td></tr>
<tr class="separator:ga2ff3d5ffd024c3d275a9258848d8ef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeea62c82e1684456b987571a306a9d0b"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gaeea62c82e1684456b987571a306a9d0b">max17048_force_quick_start</a> (void)</td></tr>
<tr class="memdesc:gaeea62c82e1684456b987571a306a9d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the MAX17048 to initiate a battery quick start.  <a href="group__max17048.html#gaeea62c82e1684456b987571a306a9d0b">More...</a><br /></td></tr>
<tr class="separator:gaeea62c82e1684456b987571a306a9d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d04668c5e05b32e99b42edb87bacdd"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga03d04668c5e05b32e99b42edb87bacdd">max17048_load_model</a> (const uint8_t *model)</td></tr>
<tr class="memdesc:ga03d04668c5e05b32e99b42edb87bacdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a custom model into the MAX17048 and enable it.  <a href="group__max17048.html#ga03d04668c5e05b32e99b42edb87bacdd">More...</a><br /></td></tr>
<tr class="separator:ga03d04668c5e05b32e99b42edb87bacdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca203ef5ad76c5b9d57929c4474527d"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#gafca203ef5ad76c5b9d57929c4474527d">max17048_get_id</a> (uint8_t *id)</td></tr>
<tr class="memdesc:gafca203ef5ad76c5b9d57929c4474527d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the one-time factory-programmable identifier value stored in the ID register.  <a href="group__max17048.html#gafca203ef5ad76c5b9d57929c4474527d">More...</a><br /></td></tr>
<tr class="separator:gafca203ef5ad76c5b9d57929c4474527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e3127bce3f3b2e6f5c3a5577b643ac"><td class="memItemLeft" align="right" valign="top">sl_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__max17048.html#ga85e3127bce3f3b2e6f5c3a5577b643ac">max17048_get_production_version</a> (uint16_t *ver)</td></tr>
<tr class="memdesc:ga85e3127bce3f3b2e6f5c3a5577b643ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the production version of the MAX17048 by reading the contents of the VERSION register.  <a href="group__max17048.html#ga85e3127bce3f3b2e6f5c3a5577b643ac">More...</a><br /></td></tr>
<tr class="separator:ga85e3127bce3f3b2e6f5c3a5577b643ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Driver for the max17048/max17049 Fuel Gauge. </p>
<p ><br  />
 </p>
<h1><a class="anchor" id="max17048_example"></a>
MAX17048 example</h1>
<p >Basic example for performing measurement: <br  />
 <br  />
 </p><pre class="fragment">#include "sl_i2cspm_instances.h"
#include "max17048.h"

int main( void )
{

  ...

  uint32_t soc;
  uint32_t vcell;

  max17048_init(sl_i2cspm_sensor_env);
  // read the ID
  max17048_get_id(&amp;id);
  max17048_get_vcell(&amp;vcell);
  max17048_get_soc(&amp;soc);

  ...

} </pre> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5328c547b89d1e336b44390abc4965d0" name="ga5328c547b89d1e336b44390abc4965d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5328c547b89d1e336b44390abc4965d0">&#9670;&nbsp;</a></span>max17048_interrupt_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* max17048_interrupt_callback_t) (sl_max17048_irq_source_t irq, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MAX17048 interrupt callback function. </p>
<p >This callback function is executed from interrupt context when the user has enabled one of the MAX17048 interrupt sources. </p>

</div>
</div>
<a id="ga680a8aa2a20465cfbcb7fdf9208c5e77" name="ga680a8aa2a20465cfbcb7fdf9208c5e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680a8aa2a20465cfbcb7fdf9208c5e77">&#9670;&nbsp;</a></span>max17048_temp_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t(* max17048_temp_callback_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MAX17048 temperature external temperature measurement callback function. </p>
<p >This callback function is executed from interrupt context when the user opts to provide the battery back temperature through a mechanism other than the integrated EMU temperature sensor (e.g. an external temperature sensor or other means). The driver needs the battery pack temperature to periodically update the MAX17048 compensation factor (RCOMP).</p>
<dl class="section return"><dt>Returns</dt><dd>Temperature, as a signed integer in degrees C. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3f9e19d54b68f884baa1de9580909b33" name="ga3f9e19d54b68f884baa1de9580909b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f9e19d54b68f884baa1de9580909b33">&#9670;&nbsp;</a></span>max17048_hibstate_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__max17048.html#ga3f9e19d54b68f884baa1de9580909b33">max17048_hibstate_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MAX17048 hibernate state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3f9e19d54b68f884baa1de9580909b33aa9827654cde2568f4f082c27746fa59f" name="gga3f9e19d54b68f884baa1de9580909b33aa9827654cde2568f4f082c27746fa59f"></a>activeMode&#160;</td><td class="fielddoc"><p >Device is in active mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f9e19d54b68f884baa1de9580909b33a59f864cf7b64c780506d1d358f9613f1" name="gga3f9e19d54b68f884baa1de9580909b33a59f864cf7b64c780506d1d358f9613f1"></a>hibernateMode&#160;</td><td class="fielddoc"><p >Device is in hibernate mode. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3da20249b4ef2fbd8dbab8fe45971c18" name="ga3da20249b4ef2fbd8dbab8fe45971c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3da20249b4ef2fbd8dbab8fe45971c18">&#9670;&nbsp;</a></span>max17048_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_deinit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize the MAX17048 driver. </p>
<p >This function does not write to any of the MAX17048 registers. Its sole purpose is to return the GPIO pin(s) used for the ALRTn and optional QSTRT pins to the disabled state.</p>
<p >The proper way to de-initialize the MAX17048 would be to manually disable all of its interrupts (or set those with thresholds to min/max values that cannot be reached) and then place the device in sleep mode by calling <a class="el" href="group__max17048.html#gaa417efb663c06cd2240cdeb63846a47e" title="Places the MAX17048 into sleep mode.">max17048_enter_sleep()</a>, which disables battery monitoring altogether.</p>
<dl class="section note"><dt>Note</dt><dd>The purpose of de-initialization is to shutdown the MAX17048 as part of a complete shutdown sequence for an EFM32/EFR32-based system. Because driver de-initialization disables interrupt recognition, it is no longer possible to detect a battery swap, even though the MAX17048 will do so and assert ALRTn. Leave the driver initialized to handle ALRTn assertion on battery swap, even if the MAX17048 has been placed in sleep mode.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_NOT_INITIALIZED if the driver is not initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga84261f39f5f2b4f65376469aa5af7534" name="ga84261f39f5f2b4f65376469aa5af7534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84261f39f5f2b4f65376469aa5af7534">&#9670;&nbsp;</a></span>max17048_disable_auto_hibernate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_disable_auto_hibernate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables automatic hibernation by setting the activity and CRATE thresholds to 0x0. </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7b10be8d77646d016c1f42637d8fe551" name="ga7b10be8d77646d016c1f42637d8fe551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b10be8d77646d016c1f42637d8fe551">&#9670;&nbsp;</a></span>max17048_disable_empty_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_disable_empty_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the MAX17048 empty alert interrupt and unregisters the the user-provided callback function. </p>
<p >The empty threshold alert interrupt is technically always active because it does not have a dedicated enable bit.</p>
<p >As explained for the <a class="el" href="group__max17048.html#ga4496efacef0e093d718a236029780ecc" title="Enables the MAX17048 empty alert interrupt, sets its threshold, and registers a user-provided callbac...">max17048_enable_empty_interrupt()</a> function the empty percent level is specified as 32 - ATHD, so setting a threshold of 1% (ATHD = 31) should prevent the interrupt from being requested and the driver will ignore it.</p>
<dl class="section note"><dt>Note</dt><dd>Because the empty threshold interrupt cannot be disabled (e.g. there is a chance that in a very low-power system operation might be possible at 1% SOC), the user should consider disabling all driver interrupts and placing the MCU in a low-power mode and polling SOC at a very slow rate if battery swap is possible.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Disables the MAX17048 empty alert interrupt and unregisters the the user-provided callback function. </dd></dl>

</div>
</div>
<a id="ga284f22aa25c9d4519842e8a2ac57c44f" name="ga284f22aa25c9d4519842e8a2ac57c44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga284f22aa25c9d4519842e8a2ac57c44f">&#9670;&nbsp;</a></span>max17048_disable_reset_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_disable_reset_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the MAX17048 reset alert interrupt and unregisters the user-provided callback function. </p>
<p >The reset alert interrupt is disabled by writing a 1 to the EnVr bit in the STATUS register.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Disables the MAX17048 reset alert interrupt and unregisters the user-provided callback function. </dd></dl>

</div>
</div>
<a id="gad7a770f000e304210f9816b29f3f1868" name="gad7a770f000e304210f9816b29f3f1868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7a770f000e304210f9816b29f3f1868">&#9670;&nbsp;</a></span>max17048_disable_soc_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_disable_soc_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the MAX17048 state-of-charge (SOC) interrupt and unregisters the user-provided callback function. </p>
<p >This function disables the SOC interrupt by writing a 0 to the ALSC bit in the MAX17048 CONFIG register.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_NOT_INITIALIZED if a callback has not previously been registered.</li>
</ul>
Disables the MAX17048 state-of-charge (SOC) interrupt and unregisters the user-provided callback function. </dd></dl>

</div>
</div>
<a id="ga3ceb5d1e51b85b9812f6e01c90f88324" name="ga3ceb5d1e51b85b9812f6e01c90f88324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ceb5d1e51b85b9812f6e01c90f88324">&#9670;&nbsp;</a></span>max17048_disable_vhigh_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_disable_vhigh_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the MAX17048 voltage high alert interrupt and unregisters the user-provided callback function. </p>
<p >The voltage high alert interrupt is technically always active because it does not have a dedicated enable bit.</p>
<p >However, the high alert level is set by the VALRT register MAX field, and if it is set to a voltage higher than the maximum VCELL level, the interrupt will never be requested. Because each LSB of MAX corresponds to 20 mV, a value of 0xFF is 5.1V, which is greater than the maximum output voltage of a single Li+ cell.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5383af8dbe8910543f0cbd5cacb0b841" name="ga5383af8dbe8910543f0cbd5cacb0b841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5383af8dbe8910543f0cbd5cacb0b841">&#9670;&nbsp;</a></span>max17048_disable_vlow_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_disable_vlow_interrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the MAX17048 voltage low alert interrupt and unregisters the user-provided callback function. </p>
<p >The voltage low alert interrupt is technically always active because it does not have a dedicated enable bit.</p>
<p >However, the low alert level is set by the VALRT register MIN field, and if it is set to a voltage lower than the minimum VCELL level, the interrupt will never be requested. Because each LSB of MAX corresponds to 20 mV, a value of 0x0 is 0V, which a voltage at which the system should not even be running.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac461439fc7a6add30ddf2bf7d530e3b7" name="gac461439fc7a6add30ddf2bf7d530e3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac461439fc7a6add30ddf2bf7d530e3b7">&#9670;&nbsp;</a></span>max17048_enable_auto_hibernate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_enable_auto_hibernate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hib_thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>act_thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables MAX17048 automatic hibernation by setting the activity and CRATE (rate of discharge/charge) thresholds to non-min/max values. </p>
<p >Hibernate allows the MAX17048 to reduce its current draw from a typical of 23 uA in active mode to 4 uA or less by increasing the ADC sampling interval from 250 ms to 45 seconds.</p>
<p >Automatic hibernation happens when the CRATE is less than the user-specified threshold. Similarly, exit from hibernate is automatic if any single VCELL reading exceeds the user-specified activity threshold.</p>
<p >As the datasheet notes, writing 0xFFFF to HIBRT forces use of automatic hibernation; similarly, 0x0000 disables. It follows, then, that a hybrid use case is possible. Setting the HIBRT register HIBTHR and ACTTHR fields to 0xFF and 0x0, respectively, will keep the device in hibernate mode with no way to exit.</p>
<dl class="section note"><dt>Note</dt><dd>The driver does not allow a use case where hib_thr = 0% and act_thr != 0x0 mV, in other words, hibernate is disabled but an activity level to cause exit from hibernate is specified. The datasheet does not specify what would happen in this case.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hib_thr</td><td>CRATE threshold below which the MAX17048 enters hibernate mode as an percent.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">act_thr</td><td>Exit hibernate mode when VCELL changes by greater than the specified amount in millivolts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_INVALID_PARAMETER if hib_thr = 0 and act_thr != 0.</li>
</ul>
Enables MAX17048 automatic hibernation by setting the activity and CRATE (rate of discharge/charge) thresholds to non-min/max values. </dd></dl>

</div>
</div>
<a id="ga4496efacef0e093d718a236029780ecc" name="ga4496efacef0e093d718a236029780ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4496efacef0e093d718a236029780ecc">&#9670;&nbsp;</a></span>max17048_enable_empty_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_enable_empty_interrupt </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>athd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a>&#160;</td>
          <td class="paramname"><em>irq_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the MAX17048 empty alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it. </p>
<p >The empty threshold alert interrupt is technically always active because it does not have a dedicated enable bit.</p>
<p >However, the alert threshold is set by the ATHD field in the CONFIG register and is defined as 32 - ATHD. Because ATHD = 0x1C at POR, the empty threshold defaults to 4%.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">athd</td><td>Empty threshold specified as a percent between 1 and 32.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_cb</td><td>User-defined function to respond to the SOC of charge falling below the specified empty threshold level.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Pointer to user data that will be passed to callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_INVALID_PARAMETER if athd &lt; 1 or athd &gt; 32.</li>
</ul>
<ul>
<li>SL_STATUS_NULL_POINTER if irq_cb or cb_data is NULL.</li>
</ul>
<ul>
<li>SL_STATUS_ALREADY_INITIALIZED if a callback has already been initialized.</li>
</ul>
Enables the MAX17048 empty alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it. </dd></dl>

</div>
</div>
<a id="ga55975d771f83912b68cd55b059a01e38" name="ga55975d771f83912b68cd55b059a01e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55975d771f83912b68cd55b059a01e38">&#9670;&nbsp;</a></span>max17048_enable_reset_comparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_enable_reset_comparator </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disabling the MAX17048 reset comparator in hibernate mode reduces current consumption by 0.5 uA. </p>
<p >The reset comparator is disabled by writing a 1 to the Dis bit in the VRESET/ID register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td><ul>
<li>true - Enable the reset comparator in hibernate mode. </li>
<li>false - Disable the reset comparator in hibernate mode.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Disabling the MAX17048 reset comparator in hibernate mode reduces current consumption by 0.5 uA. </dd></dl>

</div>
</div>
<a id="ga77d5f41ce5b13ed29b0cb796ccd2b723" name="ga77d5f41ce5b13ed29b0cb796ccd2b723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77d5f41ce5b13ed29b0cb796ccd2b723">&#9670;&nbsp;</a></span>max17048_enable_reset_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_enable_reset_interrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>vreset_mv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a>&#160;</td>
          <td class="paramname"><em>irq_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the MAX17048 reset alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it. </p>
<p >The reset alert interrupt is used to detect battery removal or a drop in the cell output voltage below which system functionality may be impaired. It is enabled by writing a 1 to the EnVr bit in the STATUS register.</p>
<p >The reset threshold is a 7-bit value specified in units of 1 LSB = 40 mV.</p>
<dl class="section note"><dt>Note</dt><dd>The driver does not fully sanity check vreset, and it is possible for the user to specify a nonsensical value that constantly triggers the interrupt. For example, vreset = 0x7F corresponds to a reset voltage of 5.08V, which is greater than the maximum output level of a single Li+ cell.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vreset_mv</td><td>Low voltage alert threshold in millivolts.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_cb</td><td>User-defined function to respond to VCELL &gt; valrt_max.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Pointer to user data that will be passed to callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_NULL_POINTER if irq_cb or cb_data is NULL.</li>
</ul>
<ul>
<li>SL_STATUS_ALREADY_INITIALIZED if a callback has already been initialized.</li>
</ul>
<ul>
<li>SL_STATUS_INVALID_PARAMETER if vreset_mv &gt; 5080.</li>
</ul>
Enables the MAX17048 reset alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it. </dd></dl>

</div>
</div>
<a id="gaa8c520e91572655c43d29e586bfc2686" name="gaa8c520e91572655c43d29e586bfc2686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8c520e91572655c43d29e586bfc2686">&#9670;&nbsp;</a></span>max17048_enable_soc_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_enable_soc_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a>&#160;</td>
          <td class="paramname"><em>irq_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the MAX17048 state-of-charge (SOC) interrupt and registers a user-provided callback function to respond to it. </p>
<p >This function enables the SOC interrupt by writing a 1 to the ALSC bit in the MAX17048 CONFIG register. The interrupt is requested whenever SOC changes by at least 1%.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_cb</td><td>User-defined function to respond to the SOC interrupt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Pointer to user data that will be passed to callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_NULL_POINTER if irq_cb or cb_data is NULL.</li>
</ul>
<ul>
<li>SL_STATUS_ALREADY_INITIALIZED if a callback has already been initialized.</li>
</ul>
Enables the MAX17048 state-of-charge (SOC) interrupt and registers a user-provided callback function to respond to it. </dd></dl>

</div>
</div>
<a id="ga2dc052e99940eb937d2648195ba8ec79" name="ga2dc052e99940eb937d2648195ba8ec79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dc052e99940eb937d2648195ba8ec79">&#9670;&nbsp;</a></span>max17048_enable_vhigh_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_enable_vhigh_interrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>valrt_max_mv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a>&#160;</td>
          <td class="paramname"><em>irq_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the MAX17048 voltage high alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it. </p>
<p >The voltage high alert interrupt is technically always active because it does not have a dedicated enable bit.</p>
<p >However, the high alert level is set by the VALRT register MAX field, and if it is set to a voltage higher than the maximum VCELL level, the interrupt will never be requested. Because each LSB of MAX corresponds to 20 mV, a value of 0xFF is 5.1V, which is greater than the maximum output voltage of a single Li+ cell.</p>
<dl class="section note"><dt>Note</dt><dd>The driver does not sanity check valrt_max. If the user sets valrt_max to a nonsensical value, e.g. 0, the interrupt will trigger constantly. There is also no requirement that valrt_max &gt; valrt_min.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">valrt_max_mv</td><td>High voltage alert threshold in millivolts.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_cb</td><td>User-defined function to respond to VCELL &gt; valrt_max.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Pointer to user data that will be passed to callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_NULL_POINTER if irq_cb or cb_data is NULL.</li>
</ul>
<ul>
<li>SL_STATUS_ALREADY_INITIALIZED if a callback has already been initialized.</li>
</ul>
Enables the MAX17048 voltage high alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it. </dd></dl>

</div>
</div>
<a id="ga44da5bcac4b8d24431134c43efc661db" name="ga44da5bcac4b8d24431134c43efc661db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44da5bcac4b8d24431134c43efc661db">&#9670;&nbsp;</a></span>max17048_enable_vlow_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_enable_vlow_interrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>valrt_min_mv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__max17048.html#ga5328c547b89d1e336b44390abc4965d0">max17048_interrupt_callback_t</a>&#160;</td>
          <td class="paramname"><em>irq_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the MAX17048 voltage low alert interrupt, sets its threshold, and registers a user-provided callback function to respond to it. </p>
<p >The voltage low alert interrupt is technically always active because it does not have a dedicated enable bit.</p>
<p >However, the low alert level is set by the VALRT register MIN field, and if it is set to a voltage lower than the minimum VCELL level, the interrupt will never be requested. Because each LSB of MIN corresponds to 20 mV, a value of 0x0 is 0V, which a voltage at which the system should not even be running.</p>
<dl class="section note"><dt>Note</dt><dd>The driver does not sanity check valrt_min. If the user sets valrt_min to a nonsensical value, e.g. 0xFF, the interrupt will trigger constantly. There is also no requirement that valrt_max &gt; valrt_min.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">valrt_min_mv</td><td>Low voltage alert threshold in millivolts.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">irq_cb</td><td>User-defined function to respond to VCELL &gt; valrt_max.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb_data</td><td>Pointer to user data that will be passed to callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_NULL_POINTER if irq_cb or cb_data is NULL.</li>
</ul>
<ul>
<li>SL_STATUS_ALREADY_INITIALIZED if a callback has already been initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa417efb663c06cd2240cdeb63846a47e" name="gaa417efb663c06cd2240cdeb63846a47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa417efb663c06cd2240cdeb63846a47e">&#9670;&nbsp;</a></span>max17048_enter_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_enter_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places the MAX17048 into sleep mode. </p>
<p >Sleep mode offers the lowest current consumption, but it cannot be used as a substitute for hibernate mode. All monitoring is disabled in sleep mode. Any discharging (or charging) of the battery, which would happen even if the EFM32/EFR32 is in a low energy mode, would not be detected and would inject error into the SOC calculations that will accumulate over time.</p>
<p >The driver places the MAX17048 in sleep mode by first writing a 1 to the EnSleep bit in the the MODE register and then by writing a 1 to the SLEEP bit in the CONFIG register.</p>
<dl class="section note"><dt>Note</dt><dd>Although sleep mode is not suitable for normal operation of the MAX17048, it would be appropriate in EM4 when the only possible wake-up event is a power-on reset (POR) caused by battery replacement.</dd>
<dd>
It is possible to force exit sleep mode by writing a 0 to the CONFIG register sleep bit. POR also exits sleep mode.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Places the MAX17048 into sleep mode. </dd></dl>

</div>
</div>
<a id="ga6540b9afc85e8af172dd3fc3435bd95f" name="ga6540b9afc85e8af172dd3fc3435bd95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6540b9afc85e8af172dd3fc3435bd95f">&#9670;&nbsp;</a></span>max17048_exit_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_exit_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the MAX17048 to exit sleep mode. </p>
<p >Although the proper exit mechanism from sleep mode would be a POR, as this causes the device to quick start its battery SOC calculations, it is possible to force exit from sleep mode by writing a 0 to the SLEEP bit in the CONFIG register.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaeea62c82e1684456b987571a306a9d0b" name="gaeea62c82e1684456b987571a306a9d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeea62c82e1684456b987571a306a9d0b">&#9670;&nbsp;</a></span>max17048_force_quick_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_force_quick_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the MAX17048 to initiate a battery quick start. </p>
<p >In general, POR should handle most battery swap events. However, if the battery cannot reach a fully relaxed state during the initial 17 ms POR window, it is possible to manually force the MAX17048 to perform initial VCELL measurements.</p>
<p >If the user has enabled hardware quick start by #defining MAX17048_CONFIG_ENABLE_HW_QSTRT and specifying the GPIO pin to which the QSTRT input is connected, the driver will use this option as it offers the lowest latency. Otherwise, the driver will initiate quick start by writing a 1 to the QuickStart bit in the MODE register.</p>
<dl class="section note"><dt>Note</dt><dd>The rising edge on QSTRT initiates the quick start, however Maxim does not provide any timing specifications for the pin. Presumably, if QSTRT were to go low and then high again during the VCELL sampling window (which looks to be 17 ms based on the discussion of what happens after POR), another quick start would be initiated.</dd></dl>
<p>For this reason, it would seem that the driver ought to keep QSTRT high for some nominal amount of time, maybe 1 ms, before de-asserting it. This should be implemented with a Sleeptimer one-shot software timer whose callback de-asserts the pin.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2ff3d5ffd024c3d275a9258848d8ef52" name="ga2ff3d5ffd024c3d275a9258848d8ef52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ff3d5ffd024c3d275a9258848d8ef52">&#9670;&nbsp;</a></span>max17048_force_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_force_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the MAX17048 to initiate a power-on reset (POR). </p>
<p >In general, POR should be detected using the MAX17048 reset comparator and its associated interrupt. However, it is possible to manually initiate a POR by writing 0x5400 to the CMD register.</p>
<dl class="section note"><dt>Note</dt><dd>The MAX17048 will issue the reset immediately after the last bit of the command is clocked into the CMD register and will not ACK the transfer.</dd>
<dd>
The reset command forces all MAX17048 registers to their default values. The driver must update its private tracking variables to reflect this.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab4dc2d4edfa30523a67483e344f5b989" name="gab4dc2d4edfa30523a67483e344f5b989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4dc2d4edfa30523a67483e344f5b989">&#9670;&nbsp;</a></span>max17048_get_activity_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t max17048_get_activity_threshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the activity threshold level. </p>
<dl class="section note"><dt>Note</dt><dd>The driver does not poll the MAX17048 to retrieve this value. At initialization it is assumed to be the default level of 0x30 and is tracked in a private variable should it otherwise be changed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Activity threshold (VCELL level) in millivolts.</li>
</ul>
Get the activity threshold level. </dd></dl>

</div>
</div>
<a id="ga1f3ff8a523f2a234df0e47965554160f" name="ga1f3ff8a523f2a234df0e47965554160f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f3ff8a523f2a234df0e47965554160f">&#9670;&nbsp;</a></span>max17048_get_crate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_get_crate </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>crate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets an approximate value for the average SOC rate of change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">crate</td><td>The average rate of change in SOC in % as a floating point value. The CRATE register returns a value expressed at 1 LSB = 0.208% per hour. The value does not specifically reflect current consumption and cannot be converted to a current.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gaf07d953475034869fee5623b842a5d26" name="gaf07d953475034869fee5623b842a5d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf07d953475034869fee5623b842a5d26">&#9670;&nbsp;</a></span>max17048_get_empty_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t max17048_get_empty_threshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the empty threshold. </p>
<dl class="section note"><dt>Note</dt><dd>The driver does not poll the MAX17048 to retrieve this value. At initialization it is assumed to be the default level of 4% and is tracked in a private variable should it otherwise be changed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Empty threshold between 1% and 32%.</li>
</ul>
Get the empty threshold. </dd></dl>

</div>
</div>
<a id="ga66daaef0642f1f20fb6a7583a31df836" name="ga66daaef0642f1f20fb6a7583a31df836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66daaef0642f1f20fb6a7583a31df836">&#9670;&nbsp;</a></span>max17048_get_hibernate_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_get_hibernate_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__max17048.html#ga3f9e19d54b68f884baa1de9580909b33">max17048_hibstate_t</a> *&#160;</td>
          <td class="paramname"><em>hibstat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the MAX17048 is in hibernate mode. </p>
<dl class="section note"><dt>Note</dt><dd>The driver only polls the MAX17048 to determine if the device is in hibernate mode if the user has enabled it. By default, the driver manually enters/exits hibernate by writing the appropriate values to HIBRT upon EM2/3 entry/exit in response to Power Manager sl_power_manager_subscribe_em_transition_event() notifications.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">hibstat</td><td><ul>
<li>activeMode - Device is in active mode </li>
<li>hibernateMode - Device is in hibernate mode</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Check if the MAX17048 is in hibernate mode. </dd></dl>

</div>
</div>
<a id="ga4d5512602578226a49a978c7e652d5ae" name="ga4d5512602578226a49a978c7e652d5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d5512602578226a49a978c7e652d5ae">&#9670;&nbsp;</a></span>max17048_get_hibernate_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float max17048_get_hibernate_threshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the hibernate threshold level. </p>
<dl class="section note"><dt>Note</dt><dd>The driver does not poll the MAX17048 to retrieve this value. At initialization it is assumed to be the default level of 0x80 and is tracked in a private variable should it otherwise be changed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Hibernate threshold in charge/discharge in percent.</li>
</ul>
Get the hibernate threshold level. </dd></dl>

</div>
</div>
<a id="gafca203ef5ad76c5b9d57929c4474527d" name="gafca203ef5ad76c5b9d57929c4474527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafca203ef5ad76c5b9d57929c4474527d">&#9670;&nbsp;</a></span>max17048_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_get_id </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the one-time factory-programmable identifier value stored in the ID register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>The value stored in the ID register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Returns the one-time factory-programmable identifier value stored in the ID register. </dd></dl>

</div>
</div>
<a id="ga85e3127bce3f3b2e6f5c3a5577b643ac" name="ga85e3127bce3f3b2e6f5c3a5577b643ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e3127bce3f3b2e6f5c3a5577b643ac">&#9670;&nbsp;</a></span>max17048_get_production_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_get_production_version </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>ver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the production version of the MAX17048 by reading the contents of the VERSION register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ver</td><td>The value stored in the VERSION register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Provides the production version of the MAX17048 by reading the contents of the VERSION register. </dd></dl>

</div>
</div>
<a id="gadbf4aa694f3692200f09d4c1bc4d42d7" name="gadbf4aa694f3692200f09d4c1bc4d42d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbf4aa694f3692200f09d4c1bc4d42d7">&#9670;&nbsp;</a></span>max17048_get_reset_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t max17048_get_reset_threshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the reset alert interrupt threshold. </p>
<dl class="section note"><dt>Note</dt><dd>The driver does not poll the MAX17048 to retrieve this value. At initialization it is assumed to be the default level of 0x4B and is tracked in a private variable should it otherwise be changed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Reset alert threshold in millivolts.</li>
</ul>
Get the reset alert interrupt threshold. </dd></dl>

</div>
</div>
<a id="ga6ac6d8d7bb558efbae9bb013b97bff22" name="ga6ac6d8d7bb558efbae9bb013b97bff22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ac6d8d7bb558efbae9bb013b97bff22">&#9670;&nbsp;</a></span>max17048_get_soc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_get_soc </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>soc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns SOC as an integer %. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">soc</td><td>The state of charge [0-100%]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise.</dd></dl>
<p>This function returns SOC as an integer %. </p>

</div>
</div>
<a id="ga2e14c854a21af022ebd49b78b520e8d1" name="ga2e14c854a21af022ebd49b78b520e8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e14c854a21af022ebd49b78b520e8d1">&#9670;&nbsp;</a></span>max17048_get_update_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t max17048_get_update_interval </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RCOMP update interval. </p>
<p >This function returns the interval at which the driver updates the MAX17048 temperature compensation factor (RCOMP). It is the timeout rate of the Sleeptimer periodic software timer callback that recalculates RCOMP and sends the updated value to the MAX17048. *</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Update rate in milliseconds. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf66c5ab7163803d9d4f9b5c6beeb48c7" name="gaf66c5ab7163803d9d4f9b5c6beeb48c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf66c5ab7163803d9d4f9b5c6beeb48c7">&#9670;&nbsp;</a></span>max17048_get_vcell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_get_vcell </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>vcell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the cell voltage in millivolts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vcell</td><td>The cell voltage expressed in millivolts as an integer. The function converts the raw output from the MAX17048 where 1 LSB = 78.125 uV/cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SL_STATUS_OK if successful. Error code otherwise. </dd></dl>

</div>
</div>
<a id="gae239698bfaeec936f207d921b65e3caf" name="gae239698bfaeec936f207d921b65e3caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae239698bfaeec936f207d921b65e3caf">&#9670;&nbsp;</a></span>max17048_get_vhigh_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t max17048_get_vhigh_threshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the voltage high alert interrupt threshold. </p>
<dl class="section note"><dt>Note</dt><dd>The driver does not poll the MAX17048 to retrieve this value. At initialization it is assumed to be the default level of 0xFF and is tracked in a private variable should it otherwise be changed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>High voltage alert threshold in millivolts.</li>
</ul>
Get the voltage high alert interrupt threshold. </dd></dl>

</div>
</div>
<a id="ga80360aaf5c8235fdfc1df138236231cf" name="ga80360aaf5c8235fdfc1df138236231cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80360aaf5c8235fdfc1df138236231cf">&#9670;&nbsp;</a></span>max17048_get_vlow_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t max17048_get_vlow_threshold </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the voltage low alert interrupt threshold. </p>
<dl class="section note"><dt>Note</dt><dd>The driver does not poll the MAX17048 to retrieve this value. At initialization it is assumed to be the default level of 0x0 and is tracked in a private variable should it otherwise be changed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Low voltage alert threshold in millivolts.</li>
</ul>
Get the voltage low alert interrupt threshold. </dd></dl>

</div>
</div>
<a id="ga46a4ac6a6d0d0f98d0cf6388a21d8214" name="ga46a4ac6a6d0d0f98d0cf6388a21d8214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46a4ac6a6d0d0f98d0cf6388a21d8214">&#9670;&nbsp;</a></span>max17048_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_init </td>
          <td>(</td>
          <td class="paramtype">sl_i2cspm_t *&#160;</td>
          <td class="paramname"><em>i2cspm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the MAX17048 driver with the values provided in the <a class="el" href="max17048__config_8h.html" title="MAX17048 Driver Configuration.">max17048_config.h</a> file. </p>
<p >This function does not write to any of the MAX17048 registers. It assigns the I2C used to communicate with the device, configures the GPIO(s) used for the ALRTn and optional QSTRT pin(s), and starts a software timer to trigger temperature (RCOMP) updates at the user-specified rate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cspm</td><td>The I2CSPM instance to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Upon return, all interrupts from the MAX17048 are masked so that firmware can enable interrupts that are required, register their callback functions, and set relevant thresholds. Interrupts are globally unmasked by calling <a class="el" href="group__max17048.html#ga048dfd6319ccc78e656d5f2819357c7d" title="Unmask MAX17048 interrupts.">max17048_unmask_interrupts()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_ALREADY_INITIALIZED the function has previously been called.</li>
</ul>
Initialize the MAX17048 driver with the values provided in the <a class="el" href="max17048__config_8h.html" title="MAX17048 Driver Configuration.">max17048_config.h</a> file. </dd></dl>

</div>
</div>
<a id="ga03d04668c5e05b32e99b42edb87bacdd" name="ga03d04668c5e05b32e99b42edb87bacdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03d04668c5e05b32e99b42edb87bacdd">&#9670;&nbsp;</a></span>max17048_load_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_load_model </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a custom model into the MAX17048 and enable it. </p>
<p >This function unlocks the TABLE registers by writing 0x57 to address 0x3F and 0x4A to address 0x3E. While the model is unlocked, battery status is not updated. The TABLE registers should be loaded and re-locked as quickly as possible by writing 0x00 to address 0x3F and 0x00 to address 0x3E.</p>
<dl class="section note"><dt>Note</dt><dd>By definition, a custom model consists of 64 bytes, written to the MAX17048 TABLE registers 16 bits at a time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>A pointer to the 64-byte model array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6c4dd46a920d4d1e44bb868038c692fc" name="ga6c4dd46a920d4d1e44bb868038c692fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c4dd46a920d4d1e44bb868038c692fc">&#9670;&nbsp;</a></span>max17048_mask_interrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void max17048_mask_interrupts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask MAX17048 interrupts. </p>
<p >This disables the high-to-low edge detection on the GPIO pin connected to the MAX17048 ALRTn output. The MAX17048 itself does not have any way to globally enable/disable interrupts. </p>

</div>
</div>
<a id="gaa1d1f3ab66a445b1289f38f1483b6425" name="gaa1d1f3ab66a445b1289f38f1483b6425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d1f3ab66a445b1289f38f1483b6425">&#9670;&nbsp;</a></span>max17048_register_temperature_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_register_temperature_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__max17048.html#ga680a8aa2a20465cfbcb7fdf9208c5e77">max17048_temp_callback_t</a>&#160;</td>
          <td class="paramname"><em>temp_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the temperature update callback for the MAX17048 driver. </p>
<p >This function is used to register a callback that periodically updates the temperature of the battery monitored by the MAX17048. By default, the driver uses the EMU temperature sensor on Series 2 EFM32/EFR32 devices.</p>
<p >However, in order for this sensor to accurately reflect the battery temperature, the MCU must be underneath (e.g. on the side of the PCB opposite) or immediately adjacent to the battery.</p>
<p >In cases where this is not possible, the battery temperature can be provided to the driver from another source, such as an external temperature sensor that is integrated with the battery or mounted in close proximity to it. The driver imposes no particular requirements on the source of the temperature other than that it is provided as a signed integer in degrees Celsius.</p>
<dl class="section note"><dt>Note</dt><dd>The driver permits only one temperature update callback function to be registered. Attempting to register another callback returns an error.</dd></dl>
<p>Firmware can unregister the current callback function, in which case the driver will revert to using the EMU temperature sensor. This can be useful to further reduce overall current draw in cases where the system enters a low-power, quiescent state such that the temperature reported by the EMU sensor is effectively the same as the battery temperature.</p>
<p >There is no attempt to synchronize expiration of the software timer that updates the MAX17048's compensation factor (RCOMP) with registration of the user-provided callback function. If the software timer expires and no callback has been registered, the EMU sensor's output is used.</p>
<p >This can be a concern if the user callback function does not actually read the temperature from whatever alternate source is used but instead simply returns a value that is updated in some asynchronous fashion. If firmware does not seed the callback function with an accurate battery temperature, the MAX17408 could report an erroneous SOC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">temp_cb</td><td>User-defined function to return the battery temperature to the driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_NULL_POINTER if the callback is NULL.</li>
</ul>
<ul>
<li>SL_STATUS_ALREADY_INITIALIZED if a callback has already been initialized. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga93e51267fe944a8e78c730cc78e6f9d4" name="ga93e51267fe944a8e78c730cc78e6f9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93e51267fe944a8e78c730cc78e6f9d4">&#9670;&nbsp;</a></span>max17048_set_activity_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_set_activity_threshold </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>act_thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the activity threshold level. </p>
<p >This function sets the VCELL threshold level evaluated my the MAX17048 to determine whether or not to exit hibernate mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">act_thr</td><td>Activity threshold (VCELL level change) in millivolts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Set the activity threshold level. </dd></dl>

</div>
</div>
<a id="ga129619245c3f1ae5b376c537d734a7ef" name="ga129619245c3f1ae5b376c537d734a7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga129619245c3f1ae5b376c537d734a7ef">&#9670;&nbsp;</a></span>max17048_set_empty_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_set_empty_threshold </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>athd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the empty threshold. </p>
<p >This function sets the level at which the empty threshold alert interrupt is requested.</p>
<dl class="section note"><dt>Note</dt><dd>Setting the empty level to 1% effectively disables the threshold alert interrupt and will cause the driver to ignore it, which means that no callback function is executed.</dd></dl>
<p>There is no requirement for a callback to be registered before changing the empty threshold. If one has not previously been registered, the driver will ignore the interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">athd</td><td>Empty threshold specified as a percent between 1 and 32.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_INVALID_PARAMETER if athd = 0 or athd &gt; 32.</li>
</ul>
Set the empty threshold. </dd></dl>

</div>
</div>
<a id="gaf0f4e9bbb181649b9655eb5643892710" name="gaf0f4e9bbb181649b9655eb5643892710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0f4e9bbb181649b9655eb5643892710">&#9670;&nbsp;</a></span>max17048_set_hibernate_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_set_hibernate_threshold </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hib_thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the hibernate threshold level. </p>
<p >This function sets the CRATE threshold level evaluated my the MAX17048 to determine whether or not to enter hibernate mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hib_thr</td><td>Hibernate threshold in charge/discharge in percent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Set the hibernate threshold level. </dd></dl>

</div>
</div>
<a id="gab3b238189efc62b2cbab34f6e75a11ec" name="gab3b238189efc62b2cbab34f6e75a11ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3b238189efc62b2cbab34f6e75a11ec">&#9670;&nbsp;</a></span>max17048_set_reset_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_set_reset_threshold </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>vreset_mv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reset alert interrupt threshold. </p>
<p >This function sets the level at which the reset alert interrupt is requested.</p>
<dl class="section note"><dt>Note</dt><dd>The driver does not fully sanity check vreset, and it is possible for the user to specify a nonsensical value that constantly triggers the interrupt. For example, vreset = 0x7F corresponds to a reset voltage of 5.08V, which is greater than the maximum output level of a single Li+ cell.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vreset_mv</td><td>Low voltage alert threshold in millivolts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_INVALID_PARAMETER if vreset_mv &gt; 5080.</li>
</ul>
Set the reset alert interrupt threshold. </dd></dl>

</div>
</div>
<a id="ga474f195b19fba6d349818c42f0853ced" name="ga474f195b19fba6d349818c42f0853ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga474f195b19fba6d349818c42f0853ced">&#9670;&nbsp;</a></span>max17048_set_update_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_set_update_interval </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the RCOMP update interval. </p>
<p >This function sets the temperature compensation factor (RCOMP) update interval. During driver initialization, the value specified by MAX17048_CONFIG_RCOMP_UPDATE_INTERVAL_MS is used and defaults to 1 minute (60000 ms). Effectively, it changes the timeout rate of the Sleeptimer periodic software timer callback that recalculates RCOMP and sends the updated value to the MAX17048.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_INVALID_PARAMETER if interval &lt; 1000 or interval &gt; 60000. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2222b6efb1cd395ebe51e14aa5e22c88" name="ga2222b6efb1cd395ebe51e14aa5e22c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2222b6efb1cd395ebe51e14aa5e22c88">&#9670;&nbsp;</a></span>max17048_set_vhigh_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_set_vhigh_threshold </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>valrt_max_mv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the voltage high alert interrupt threshold. </p>
<p >This function sets the level at which the voltage high alert interrupt is requested.</p>
<dl class="section note"><dt>Note</dt><dd>The driver does not sanity check valrt_max. If the user sets valrt_max to a nonsensical value, e.g. 0, the interrupt will trigger constantly. There is also no requirement that valrt_max &gt; valrt_min.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">valrt_max_mv</td><td>High voltage alert threshold in millivolts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Set the voltage high alert interrupt threshold. </dd></dl>

</div>
</div>
<a id="ga4bbe2d0282a213364c9b00cb6476a5f5" name="ga4bbe2d0282a213364c9b00cb6476a5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bbe2d0282a213364c9b00cb6476a5f5">&#9670;&nbsp;</a></span>max17048_set_vlow_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_set_vlow_threshold </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>valrt_min_mv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the voltage low alert interrupt threshold. </p>
<p >This function sets the level at which the voltage low alert interrupt is requested.</p>
<dl class="section note"><dt>Note</dt><dd>The driver does not sanity check valrt_min. If the user sets valrt_min to a nonsensical value, e.g. 0xFF, the interrupt will trigger constantly. There is also no requirement that valrt_max &gt; valrt_min.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">valrt_min_mv</td><td>Low voltage alert threshold in millivolts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
Set the voltage low alert interrupt threshold. </dd></dl>

</div>
</div>
<a id="ga048dfd6319ccc78e656d5f2819357c7d" name="ga048dfd6319ccc78e656d5f2819357c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga048dfd6319ccc78e656d5f2819357c7d">&#9670;&nbsp;</a></span>max17048_unmask_interrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void max17048_unmask_interrupts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmask MAX17048 interrupts. </p>
<p >This enables the high-to-low edge detection on the GPIO pin connected to the MAX17048 ALRTn output. The MAX17048 itself does not have any way to globally enable/disable interrupts. </p>

</div>
</div>
<a id="ga42e42578f78e2d4d25ef8c875dc6f96e" name="ga42e42578f78e2d4d25ef8c875dc6f96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42e42578f78e2d4d25ef8c875dc6f96e">&#9670;&nbsp;</a></span>max17048_unregister_temperature_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sl_status_t max17048_unregister_temperature_callback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister the temperature update callback for the MAX17048 driver. </p>
<p >This is the opposite of <a class="el" href="group__max17048.html#gaa1d1f3ab66a445b1289f38f1483b6425" title="Register the temperature update callback for the MAX17048 driver.">max17048_register_temperature_callback()</a>. It unregisters the previously-registered temperature update callback function and causes the driver to revert to the output of the EMU temperature sensor when next updating the MAX17048's RCOMP value.</p>
<p >There is no attempt to unregister the user-provided callback function before expiration of the software timer that updates RCOMP. If the timer expires and the callback is still registered, it must provide a valid temperature to the driver.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>SL_STATUS_OK on success.</li>
</ul>
<ul>
<li>SL_STATUS_NOT_INITIALIZED if a callback has not previously been registered. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
